1
00:00:04,000 --> 00:00:08,720
因此，clo 在幾週前推出了這個子代理功能

2
00:00:06,560 --> 00:00:10,639
。這是一個非常令人興奮的

3
00:00:08,720 --> 00:00:12,639
概念。然而，對於嘗試過

4
00:00:10,639 --> 00:00:14,559
它的人來說，他們經常會得到相當負面的

5
00:00:12,639 --> 00:00:16,400
體驗，其中子代理感覺很慢，

6
00:00:14,559 --> 00:00:17,680
消耗了更多的令牌，最

7
00:00:16,400 --> 00:00:19,680
重要的是感覺它並沒有帶來

8
00:00:17,680 --> 00:00:21,359
更好的結果。我

9
00:00:19,680 --> 00:00:23,119
就是其中之一，但直到

10
00:00:21,359 --> 00:00:25,279
最近我才開始學習

11
00:00:23,119 --> 00:00:26,880
使用子代理的最佳實踐，這

12
00:00:25,279 --> 00:00:28,400
徹底改變了遊戲規則並使我的

13
00:00:26,880 --> 00:00:30,160
雲端程式碼始終表現得更好

14
00:00:28,400 --> 00:00:31,679
。這就是為什麼今天我想

15
00:00:30,160 --> 00:00:33,680
分享我如何思考和設計

16
00:00:31,679 --> 00:00:35,840
子代理系統。因此，首先我們要

17
00:00:33,680 --> 00:00:37,920
了解為什麼雲代碼

18
00:00:35,840 --> 00:00:39,600
最初要引入子代理概念，如果您

19
00:00:37,920 --> 00:00:41,440
不知道雲代碼代理在

20
00:00:39,600 --> 00:00:43,600
後台的具體工作原理，它基本上是一個

21
00:00:41,440 --> 00:00:45,600
名為代理的工具，配備了

22
00:00:43,600 --> 00:00:47,600
用於讀取文件、

23
00:00:45,600 --> 00:00:49,600
列出所有文件、編輯文件等不同工具的列表，

24
00:00:47,600 --> 00:00:51,680
並且某有些工具可能會消耗

25
00:00:49,600 --> 00:00:52,879
更多的令牌，例如讀取工具，因為

26
00:00:51,680 --> 00:00:55,039
您要將

27
00:00:52,879 --> 00:00:57,039
檔案的整個內容包含到對話

28
00:00:55,039 --> 00:00:58,879
歷史記錄中，並且在雲端程式碼具有子代理功能之前，

29
00:00:57,039 --> 00:01:00,960
所有操作都將由

30
00:00:58,879 --> 00:01:02,719
雲端程式碼代理本身完成，這

31
00:01:00,960 --> 00:01:04,879
表示在它開始實作之前，它

32
00:01:02,719 --> 00:01:06,400
可能已經使用了80％ 的上下文

33
00:01:04,879 --> 00:01:08,000
窗口，因為這些文件將包含

34
00:01:06,400 --> 00:01:10,080
大量上下文，這

35
00:01:08,000 --> 00:01:11,760
可能會觸發這個

36
00:01:10,080 --> 00:01:13,520

37
00:01:11,760 --> 00:01:15,200

38
00:01:13,520 --> 00:01:16,479
緊湊的

39
00:01:15,200 --> 00:01:18,080
對話

40
00:01:16,479 --> 00:01:19,600

41
00:01:18,080 --> 00:01:21,200

42
00:01:19,600 --> 00:01:23,280

43
00:01:21,200 --> 00:01:25,280
命令，該命令將在繼續進行之前總結整個對話。我們知道，每次當你壓縮對話時，效能就會急劇下降，因為它開始失去之前所做事情的上下文。這就是為什麼後來他們為雲端代碼代理引入

44
00:01:23,280 --> 00:01:27,200

45
00:01:25,280 --> 00:01:29,520
了這個任務

46
00:01:27,200 --> 00:01:31,840
工具。  它允許雲端代碼將任務分配給另一個代理，並且該代理將擁有完全相同的工具集，包括讀取

47
00:01:29,520 --> 00:01:33,600
文件、搜尋文件。因此，您可以觸發

48
00:01:31,840 --> 00:01:35,439
此代理來實際掃描整個程式

49
00:01:33,600 --> 00:01:37,280

50
00:01:35,439 --> 00:01:39,280

51
00:01:37,280 --> 00:01:41,119

52
00:01:39,280 --> 00:01:43,439

53
00:01:41,119 --> 00:01:45,360
碼庫，了解所有需要更改的相關文件，

54
00:01:43,439 --> 00:01:46,960

55
00:01:45,360 --> 00:01:48,880

56
00:01:46,960 --> 00:01:50,799

57
00:01:48,880 --> 00:01:52,960

58
00:01:50,799 --> 00:01:55,119
然後基於該資訊

59
00:01:52,960 --> 00:01:56,880

60
00:01:55,119 --> 00:01:58,719

61
00:01:56,880 --> 00:02:00,880
進行實際實施，保存令牌的方式是因為從父代理的角度來看，子代理在中間採取的所有步驟都不會成為父代理對話歷史記錄的一部分，它只能看到它將任務分配給子代理，然後子代理返回研究報告透過這樣做，您會將

62
00:01:58,719 --> 00:02:03,119

63
00:02:00,880 --> 00:02:05,280
讀取檔案搜尋

64
00:02:03,119 --> 00:02:07,119
檔案操作中的大量令牌消耗致命地轉變為僅僅

65
00:02:05,280 --> 00:02:08,560
幾百個令牌摘要，但仍

66
00:02:07,119 --> 00:02:10,399
包含

67
00:02:08,560 --> 00:02:12,239
指導下一步操作的最重要資訊。因此，

68
00:02:10,399 --> 00:02:14,080
子代理的整個目的一直圍繞著

69
00:02:12,239 --> 00:02:16,239
上下文工程師和上下文

70
00:02:14,080 --> 00:02:18,319
優化，但當

71
00:02:16,239 --> 00:02:20,560
人們開始嘗試讓子

72
00:02:18,319 --> 00:02:21,920

73
00:02:20,560 --> 00:02:23,920

74
00:02:21,920 --> 00:02:25,920

75
00:02:23,920 --> 00:02:28,160

76
00:02:25,920 --> 00:02:30,160
代理不僅進行

77
00:02:28,160 --> 00:02:32,879

78
00:02:30,160 --> 00:02:35,120

79
00:02:32,879 --> 00:02:36,480

80
00:02:35,120 --> 00:02:38,000

81
00:02:36,480 --> 00:02:40,080

82
00:02:38,000 --> 00:02:41,680
研究工作而且還直接實施時，事情就失敗了。例如，我的第一個想法是，如果我們可以讓前端開發代理只做具有特殊規則和工作流程的前端實現，並讓後端開發代理專門負責後端實現，那會怎麼樣？然後對於父代理來說，它實際上只是協調整個對話並將任務委派給

83
00:02:40,080 --> 00:02:43,519
其他人。一開始這聽起來確實不錯，

84
00:02:41,680 --> 00:02:46,400
但是如果

85
00:02:43,519 --> 00:02:48,239
實施的任何子代理程式不是 100% 正確，

86
00:02:46,400 --> 00:02:50,080
並且您希望代理程式修復它。

87
00:02:48,239 --> 00:02:52,000
問題就在這裡，因為對於每個

88
00:02:50,080 --> 00:02:54,000
代理商來說，它只擁有非常有限的

89
00:02:52,000 --> 00:02:55,920
關於正在發生的事情的資訊。對於

90
00:02:54,000 --> 00:02:57,920
前端開發代理，它只知道

91
00:02:55,920 --> 00:03:00,160
它採取的操作以及它

92
00:02:57,920 --> 00:03:02,319
在該特定

93
00:03:00,160 --> 00:03:04,400
任務中產生的最終訊息。後端開發代理也一樣。

94
00:03:02,319 --> 00:03:06,159
如果您提示雲端程式碼代理程式

95
00:03:04,400 --> 00:03:08,159
存在前端錯誤，即使它

96
00:03:06,159 --> 00:03:09,920
再次指派給前端開發人員，這

97
00:03:08,159 --> 00:03:11,599
只會觸發新的對話，

98
00:03:09,920 --> 00:03:13,360
因為前端開發代理程式不

99
00:03:11,599 --> 00:03:15,360
知道上次前端會話中發生了什麼，

100
00:03:13,360 --> 00:03:17,440
也不會了解

101
00:03:15,360 --> 00:03:19,360
後端開發人員

102
00:03:17,440 --> 00:03:21,440
之前所做的事情的任何背景資訊。因此每個任務都是非常

103
00:03:19,360 --> 00:03:23,519
包含的會話。同時，對於

104
00:03:21,440 --> 00:03:25,920
父雲代碼代理，它也擁有

105
00:03:23,519 --> 00:03:28,080
非常有限的信息，因為它

106
00:03:25,920 --> 00:03:30,400
不會再次看到

107
00:03:28,080 --> 00:03:31,920
子代理所採取的所有操作，這意味著它

108
00:03:30,400 --> 00:03:33,360
想知道已

109
00:03:31,920 --> 00:03:35,360
創建了哪些特定文件以及他們實際上

110
00:03:33,360 --> 00:03:37,360
在這些文件中放入了什麼。所有父代理都

111
00:03:35,360 --> 00:03:39,440
看到

112
00:03:37,360 --> 00:03:41,599

113
00:03:39,440 --> 00:03:43,040

114
00:03:41,599 --> 00:03:45,040

115
00:03:43,040 --> 00:03:46,640

116
00:03:45,040 --> 00:03:48,799

117
00:03:46,640 --> 00:03:50,879

118
00:03:48,799 --> 00:03:53,280
我將任務分配給前端開發人員，並且前端開發人員協助我完成任務，並且後端也做同樣的事情。因此，如果您想讓雲端代碼代理本身修復錯誤，那麼關於導致問題的原因的資訊將非常有限。這個問題可能以後會解決。我們將

119
00:03:50,879 --> 00:03:55,120
找到一種在不同的代理之間共享上下文的好方法，以便

120
00:03:53,280 --> 00:03:56,959

121
00:03:55,120 --> 00:03:58,959

122
00:03:56,959 --> 00:04:01,280

123
00:03:58,959 --> 00:04:04,000
每個代理對於所做的事情始終有相同的理解。但就目前而言，最佳做法是將每個子代理視為研究

124
00:04:01,280 --> 00:04:05,760
人員，並思考

125
00:04:04,000 --> 00:04:07,519
什麼樣的規劃和研究

126
00:04:05,760 --> 00:04:09,680
步驟實際上可以顯著改善

127
00:04:07,519 --> 00:04:11,439
您目前的 AI 編碼工作流程。

128
00:04:09,680 --> 00:04:13,120

129
00:04:11,439 --> 00:04:14,879

130
00:04:13,120 --> 00:04:16,799

131
00:04:14,879 --> 00:04:18,639

132
00:04:16,799 --> 00:04:20,079

133
00:04:18,639 --> 00:04:22,079

134
00:04:20,079 --> 00:04:24,000
我還

135
00:04:22,079 --> 00:04:27,120
收到了來自雲端程式碼團隊的關鍵工程師之一 Adam Wolf 的類似回饋，他說當子代理只是尋找資訊並向主對話線程提供少量摘要時，其工作效果最佳。因此，有了這個，我就有了這個想法。如果每個服務

136
00:04:24,000 --> 00:04:29,680
提供者（例如 Versell AI SDK、Superbase、

137
00:04:27,120 --> 00:04:31,520
Tailwind）都

138
00:04:29,680 --> 00:04:33,440

139
00:04:31,520 --> 00:04:35,600

140
00:04:33,440 --> 00:04:37,840

141
00:04:35,600 --> 00:04:39,840

142
00:04:37,840 --> 00:04:41,520

143
00:04:39,840 --> 00:04:43,520

144
00:04:41,520 --> 00:04:46,000

145
00:04:43,520 --> 00:04:48,240

146
00:04:46,000 --> 00:04:50,240
可以擁有一個配備有關其

147
00:04:48,240 --> 00:04:52,320

148
00:04:50,240 --> 00:04:54,320
文件、最佳實踐和設計的所有最新知識的代理，然後

149
00:04:52,320 --> 00:04:56,720

150
00:04:54,320 --> 00:04:59,840

151
00:04:56,720 --> 00:05:01,520

152
00:04:59,840 --> 00:05:04,160
該代理可以開始查看我現有的程式碼庫並製定實施計劃。這正是我嘗試過的。我開始為每項服務從 chassen 創建不同的專家子代理，它可以訪問特殊的 MCP 工具，該工具可以檢索相關組件和相同的設計來完成非常好的前端工作，或者 Versell AI SDK 專家，它裝有最新的 vers SDK v5 文檔，因為他們幾週前

153
00:05:01,520 --> 00:05:06,320
剛剛發布了這個新版本，或者一個條紋專家，它裝有一條條紋等工具，因此

154
00:05:04,160 --> 00:05:08,800

155
00:05:06,320 --> 00:05:11,120

156
00:05:08,800 --> 00:05:13,120

157
00:05:11,120 --> 00:05:15,120
您可以非常輕鬆地

158
00:05:13,120 --> 00:05:16,560

159
00:05:15,120 --> 00:05:18,160

160
00:05:16,560 --> 00:05:20,240

161
00:05:18,160 --> 00:05:21,919

162
00:05:20,240 --> 00:05:23,840

163
00:05:21,919 --> 00:05:25,440
進行複雜的設置，例如基於使用情況的定價。同時，我也對不同代理

164
00:05:23,840 --> 00:05:27,440
之間的上下文共享做了一些優化。這是我在 manus 團隊

165
00:05:25,440 --> 00:05:29,759

166
00:05:27,440 --> 00:05:31,919
部落格的

167
00:05:29,759 --> 00:05:33,919
context engineer 上學到的，

168
00:05:31,919 --> 00:05:35,680

169
00:05:33,919 --> 00:05:37,759
他們在部落格中討論瞭如何讓

170
00:05:35,680 --> 00:05:40,080

171
00:05:37,759 --> 00:05:42,160

172
00:05:40,080 --> 00:05:43,759
manus 執行長時間運行任務的

173
00:05:42,160 --> 00:05:45,680
所有技巧和竅門。其中有

174
00:05:43,759 --> 00:05:47,280

175
00:05:45,680 --> 00:05:49,120
很多好東西，但最讓我啟發的是他們如何使用檔案系統作為最終的上下文管理系統。因此，

176
00:05:47,280 --> 00:05:51,440
他們不會將所有工具結果直接儲存在對話歷史記錄中，而是將

177
00:05:49,120 --> 00:05:53,360
結果接收到本地文件中，

178
00:05:51,440 --> 00:05:54,720
以便以後檢索

179
00:05:53,360 --> 00:05:56,720
。在他們的情況

180
00:05:54,720 --> 00:05:58,639
下，當代理程式運行

181
00:05:56,720 --> 00:06:01,120
網頁抓取工具時，他們不會將整個內容

182
00:05:58,639 --> 00:06:02,560
腳本直接包含在對話歷史記錄中（這可能需要超過 10,000 個令牌），而是將腳本內容

183
00:06:01,120 --> 00:06:04,639

184
00:06:02,560 --> 00:06:06,960

185
00:06:04,639 --> 00:06:08,240
保存到本地 MD 文件中，該文件可以在以後的任何對話點檢索。這正是我在這裡設計的。在文件雲端資料夾中，

186
00:06:06,960 --> 00:06:10,160

187
00:06:08,240 --> 00:06:12,000

188
00:06:10,160 --> 00:06:13,919
將有

189
00:06:12,000 --> 00:06:15,280
一個任務資料夾，其中包含您

190
00:06:13,919 --> 00:06:17,360

191
00:06:15,280 --> 00:06:19,039
希望團隊實現的每個功能的上下文。同時，每個

192
00:06:17,360 --> 00:06:21,039
子代理程式可以開始創建有關

193
00:06:19,039 --> 00:06:22,960

194
00:06:21,039 --> 00:06:25,039
具體

195
00:06:22,960 --> 00:06:27,199

196
00:06:25,039 --> 00:06:29,039

197
00:06:27,199 --> 00:06:30,880

198
00:06:29,039 --> 00:06:33,440

199
00:06:30,880 --> 00:06:35,360
研究報告和實施計劃的 MD 文件，以便

200
00:06:33,440 --> 00:06:37,199
父代理始終創建一個上下文文件，其中包含有關我們嘗試執行的具體項目的所有資訊。並且

201
00:06:35,360 --> 00:06:39,280
每個下屬在開始工作之前，都會先閱讀這個上下文文件，

202
00:06:37,199 --> 00:06:41,039
以了解整個專案的計劃和當前的進展。完成後，他們

203
00:06:39,280 --> 00:06:42,800
還將更新

204
00:06:41,039 --> 00:06:44,240
上下文文件以指示他們所做的核心步驟，並將研究報告保存到 Dock 中的 MD

205
00:06:42,800 --> 00:06:45,919
文件中

206
00:06:44,240 --> 00:06:47,680
。因此，父代理或所有其他代理稍後

207
00:06:45,919 --> 00:06:49,039
可以閱讀此對話以獲取更多背景資訊

208
00:06:47,680 --> 00:06:50,880

209
00:06:49,039 --> 00:06:52,720
。這種設定大大提高了我的雲端程式碼的成功率和結果。這就是我

210
00:06:50,880 --> 00:06:54,639
今天想要快速向你們展示的內容。因此希望

211
00:06:52,720 --> 00:06:56,080

212
00:06:54,639 --> 00:06:58,240
您能夠了解可以

213
00:06:56,080 --> 00:07:00,479
建立哪種類型的子代理並且它們實際上很有用。但在我們

214
00:06:58,240 --> 00:07:02,319

215
00:07:00,479 --> 00:07:04,639

216
00:07:02,319 --> 00:07:06,720

217
00:07:04,639 --> 00:07:08,880

218
00:07:06,720 --> 00:07:11,520

219
00:07:08,880 --> 00:07:12,960

220
00:07:11,520 --> 00:07:14,639

221
00:07:12,960 --> 00:07:16,800
深入探討這個問題之前，我知道你們中的許多人都是第一次務農。  建構產品只是難題的一部分。您還需要學習

222
00:07:14,639 --> 00:07:18,960
如何獲取用戶、如何定價以及如何向客戶證明價值

223
00:07:16,800 --> 00:07:21,120

224
00:07:18,960 --> 00:07:22,880

225
00:07:21,120 --> 00:07:25,120
。這就是為什麼我想向你們介紹這種叫做賺錢人工智慧代理商的免費材料。  這項工作由發展最快的 AI 明星公司之一 M Studio 的創始人兼首席執行官 Dimmitri Shapier 完成。他分享了他的整個歷程和經驗，從發現正在解決的

226
00:07:22,880 --> 00:07:27,199

227
00:07:25,120 --> 00:07:29,280
真正

228
00:07:27,199 --> 00:07:31,360
問題一直到定價和

229
00:07:29,280 --> 00:07:33,120
達成交易，涵蓋了所有實際和必要的

230
00:07:31,360 --> 00:07:34,800

231
00:07:33,120 --> 00:07:36,639

232
00:07:34,800 --> 00:07:38,400

233
00:07:36,639 --> 00:07:40,720
工作流程、工具和流程。它甚至包括他如何向客戶進行演示的具體腳本，

234
00:07:38,400 --> 00:07:42,400
以及許多關於人們如何構建和推出獲得

235
00:07:40,720 --> 00:07:44,160

236
00:07:42,400 --> 00:07:46,080
六到七位數年

237
00:07:44,160 --> 00:07:47,919
經常

238
00:07:46,080 --> 00:07:49,520
性收入的人工智慧產品的真實案例研究。我最喜歡的部分是如何

239
00:07:47,919 --> 00:07:51,440
考慮你的

240
00:07:49,520 --> 00:07:53,520
人工智慧產品和服務的定價。企業與 SMB 的工作框架不同，以及如何從顧客的角度評估價值。它有

241
00:07:51,440 --> 00:07:55,120

242
00:07:53,520 --> 00:07:57,599

243
00:07:55,120 --> 00:07:59,039

244
00:07:57,599 --> 00:08:01,199

245
00:07:59,039 --> 00:08:03,280
一個多小時的實用指南以及您可以免費開始使用的指南。您可以點擊下面

246
00:08:01,199 --> 00:08:04,879

247
00:08:03,280 --> 00:08:06,479

248
00:08:04,879 --> 00:08:08,400

249
00:08:06,479 --> 00:08:10,479

250
00:08:08,400 --> 00:08:12,479

251
00:08:10,479 --> 00:08:14,639
描述中的連結來獲取此資源，感謝 HubSpot 為我們帶來這些精彩的材料。現在讓我們開始建立一些雲端程式碼子代理

252
00:08:12,479 --> 00:08:16,479
程式

253
00:08:14,639 --> 00:08:18,080

254
00:08:16,479 --> 00:08:20,479
。因此，為了建立這些子代理，我的一般規則是，我將在系統屬性中直接包含許多重要文檔，

255
00:08:18,080 --> 00:08:22,639

256
00:08:20,479 --> 00:08:24,479

257
00:08:22,639 --> 00:08:26,479

258
00:08:24,479 --> 00:08:28,720
這樣我就可以確信它將遵循最新的實踐，同時我還會為他們提供隨機工具來檢索重要上下文。在這個底盤和專家範例中，正如我之前提到的，

259
00:08:26,479 --> 00:08:31,440

260
00:08:28,720 --> 00:08:33,519

261
00:08:31,440 --> 00:08:35,360
有

262
00:08:33,519 --> 00:08:37,200
專門為從特定套件中

263
00:08:35,360 --> 00:08:38,880
檢索資訊而設計的 MCP 工具。一個是這個底盤和組件MCP。它們允許

264
00:08:37,200 --> 00:08:40,560

265
00:08:38,880 --> 00:08:43,279
您檢索組件、

266
00:08:40,560 --> 00:08:45,440

267
00:08:43,279 --> 00:08:47,760

268
00:08:45,440 --> 00:08:50,080

269
00:08:47,760 --> 00:08:52,240
每個組件的範例程式碼和相關區塊。

270
00:08:50,080 --> 00:08:53,760
因此它將具有四個上下文以及另一個 MCP 來檢索和設計底盤。這個 MCP 來自 Twix，這是一個專門從事場景設計的網站，這個 MCP 將檢索一些設計良好的場景，

271
00:08:52,240 --> 00:08:55,519

272
00:08:53,760 --> 00:08:57,600

273
00:08:55,519 --> 00:08:59,200
以便可以用作參考

274
00:08:57,600 --> 00:09:01,120
。

275
00:08:59,200 --> 00:09:03,440
通常

276
00:09:01,120 --> 00:09:05,600
我會打開終端到

277
00:09:03,440 --> 00:09:07,360
code.claw.json。  這將打開您的全域

278
00:09:05,600 --> 00:09:09,279
設置，這裡有一個名為 MCP 伺服器的鍵，我將這個 chassen 元件和 chassen 同步工具傳遞到其中

279
00:09:07,360 --> 00:09:10,959
。

280
00:09:09,279 --> 00:09:12,480
因此子代理將有權訪問，我們可以

281
00:09:10,959 --> 00:09:14,399
選擇哪個工具代理

282
00:09:12,480 --> 00:09:16,560
應該

283
00:09:14,399 --> 00:09:18,240
有權訪問模型顏色，然後您將看到這個新建立的代理。如果您

284
00:09:16,560 --> 00:09:20,000
願意，您可以新增代理，但

285
00:09:18,240 --> 00:09:22,000
我通常會打開終端，然後執行程式碼文件時鐘。因此這將打開

286
00:09:20,000 --> 00:09:23,760

287
00:09:22,000 --> 00:09:25,680

288
00:09:23,760 --> 00:09:27,040
您的雲端代碼個人設置，該設置將應用於所有購買。  因此，

289
00:09:25,680 --> 00:09:29,040
我們將建立一個

290
00:09:27,040 --> 00:09:31,040
新的代理，我們可以建立一個專案

291
00:09:29,040 --> 00:09:33,440

292
00:09:31,040 --> 00:09:36,000

293
00:09:33,440 --> 00:09:37,920
特定的代理或個人層級的代理，用於所有購買。對於我們的

294
00:09:36,000 --> 00:09:40,080
例子，我將使用個人級別，我們可以

295
00:09:37,920 --> 00:09:42,240
產生爪子。它將嘗試根據您的快速解釋來

296
00:09:40,080 --> 00:09:44,320

297
00:09:42,240 --> 00:09:46,480

298
00:09:44,320 --> 00:09:48,399
產生該子代理的標題描述和系統提示

299
00:09:46,480 --> 00:09:50,399
。所以這裡我

300
00:09:48,399 --> 00:09:52,399
給的

301
00:09:50,399 --> 00:09:54,080

302
00:09:52,399 --> 00:09:56,160
描述是，它是一個 chassen 前端專家，可以幫助設計 workass

303
00:09:54,080 --> 00:09:58,240

304
00:09:56,160 --> 00:10:00,240

305
00:09:58,240 --> 00:10:01,600

306
00:10:00,240 --> 00:10:03,680

307
00:10:01,600 --> 00:10:05,920
前端 UI 相關底盤 MCPS，如前所述，我在這裡使用了特殊的 MCP 工具。  您可以在這裡看到它在此處創建的一個例子。通常，此時我所做的要么是將文件貼到他們的系統提示中，要么附加特殊的 MCP 工具

308
00:10:03,680 --> 00:10:08,320

309
00:10:05,920 --> 00:10:10,480
以及有關如何使用此 MCP 工具的規則。在

310
00:10:08,320 --> 00:10:12,959

311
00:10:10,480 --> 00:10:14,880

312
00:10:12,959 --> 00:10:17,040
我之前設計的最終版本中，它包含了所有關於它應該遵循的流程的規則。因此，這裡的總體計劃

313
00:10:14,880 --> 00:10:19,040
是

314
00:10:17,040 --> 00:10:20,640
列出所有組件，選擇正確的

315
00:10:19,040 --> 00:10:22,240
組件並獲取示例代碼以了解如何準確使用它，

316
00:10:20,640 --> 00:10:25,040

317
00:10:22,240 --> 00:10:26,880

318
00:10:25,040 --> 00:10:28,640
還可以獲取有關如何使用塊將不同的 UI

319
00:10:26,880 --> 00:10:30,079
模式組合在一起的一些參考，獲取相關的接縫以及有關將哪些組件文件放在

320
00:10:28,640 --> 00:10:32,000

321
00:10:30,079 --> 00:10:33,440
何處的一些規則，通常我還會做的是，

322
00:10:32,000 --> 00:10:35,200
首先為

323
00:10:33,440 --> 00:10:37,519

324
00:10:35,200 --> 00:10:39,040

325
00:10:37,519 --> 00:10:40,560
每個子代理程序添加一個目標，我會

326
00:10:39,040 --> 00:10:42,640
提到一個設計文件，最後我還將包含此輸出格式以

327
00:10:40,560 --> 00:10:44,399
指示最終消息輸出應類似於此我已經創建了計劃作為此文件，請在

328
00:10:42,640 --> 00:10:46,320

329
00:10:44,399 --> 00:10:48,160

330
00:10:46,320 --> 00:10:50,000

331
00:10:48,160 --> 00:10:51,920
繼續之前先閱讀該消息，此消息

332
00:10:50,000 --> 00:10:54,000

333
00:10:51,920 --> 00:10:55,920

334
00:10:54,000 --> 00:10:58,560
將

335
00:10:55,920 --> 00:11:00,800
發送回雲代碼父代理，以便每個人都知道我需要查找此文件以及不同規則的列表以繼續指示實際上不執行實施，在您進行任何工作之前，它應該先查看上下文文件以獲取完整的上下文文件以獲取完整的上下文MCP 用戶端並將其自身稱為

336
00:10:58,560 --> 00:11:03,279
我的可疑，因為子代理實際上

337
00:11:00,800 --> 00:11:05,760
繼承了

338
00:11:03,279 --> 00:11:07,519

339
00:11:05,760 --> 00:11:09,839

340
00:11:07,519 --> 00:11:12,240

341
00:11:09,839 --> 00:11:14,000

342
00:11:12,240 --> 00:11:16,959
我們擁有的 cloud.md 文件，所以我只需在此處添加此規則以確保它不會混淆，並且此

343
00:11:14,000 --> 00:11:19,040

344
00:11:16,959 --> 00:11:20,880
輸出格式和規則以及

345
00:11:19,040 --> 00:11:22,800
目標在我創建的所有子代理中幾乎相同，例如對於這個 versel

346
00:11:20,880 --> 00:11:25,040

347
00:11:22,800 --> 00:11:26,720
AI SDK 專家，

348
00:11:25,040 --> 00:11:28,959
我的輸出格式和根結構也相同，這將直接

349
00:11:26,720 --> 00:11:31,200
從 SDKvers 上獲取最新的文檔。我只是將

350
00:11:28,959 --> 00:11:34,160
一些

351
00:11:31,200 --> 00:11:36,640
關於 versile AI SDK v5 的重要基礎頁面

352
00:11:34,160 --> 00:11:38,720
以及遷移指南複製到系統道具中，以

353
00:11:36,640 --> 00:11:41,760
清楚地表明

354
00:11:38,720 --> 00:11:43,839
4.0 和 5.0 之間的區別，這也是我

355
00:11:41,760 --> 00:11:46,399
從他們自己的文檔中獲得的。

356
00:11:43,839 --> 00:11:48,079

357
00:11:46,399 --> 00:11:49,600

358
00:11:48,079 --> 00:11:51,519

359
00:11:49,600 --> 00:11:53,680

360
00:11:51,519 --> 00:11:56,079

361
00:11:53,680 --> 00:11:58,399
這是

362
00:11:56,079 --> 00:12:00,480
一個範例，說明我們如何為您將要使用的每項服務設定專門的子代理程式。現在讓我們試試看。我們首先使用 chassian 建立一個 nextjs 項目，然後我將執行 cd my app 和 claw。這將建立初始項目。我在其中開始

363
00:11:58,399 --> 00:12:02,240
初始化程式碼庫並創建

364
00:12:00,480 --> 00:12:04,320
基本雲端程式碼規則。現在我將

365
00:12:02,240 --> 00:12:06,880
創建這個雲 MD 檔案。但為了讓它

366
00:12:04,320 --> 00:12:08,720
在雲端 MD 中更好地工作，我

367
00:12:06,880 --> 00:12:11,200
還想添加一些關於

368
00:12:08,720 --> 00:12:13,760
子代理的特殊規則。因此，首先我希望這個父

369
00:12:11,200 --> 00:12:15,920
代理始終將專案計劃保存在

370
00:12:13,760 --> 00:12:17,920
doc/task/c

371
00:12:15,920 --> 00:12:19,839
聯繫會話中，以便我們可以使用此

372
00:12:17,920 --> 00:12:21,839
文件作為選擇的來源來維護其

373
00:12:19,839 --> 00:12:24,399
上下文，

374
00:12:21,839 --> 00:12:25,760

375
00:12:24,399 --> 00:12:28,240

376
00:12:25,760 --> 00:12:30,079

377
00:12:28,240 --> 00:12:31,839

378
00:12:30,079 --> 00:12:34,079

379
00:12:31,839 --> 00:12:35,839
並且在

380
00:12:34,079 --> 00:12:37,440

381
00:12:35,839 --> 00:12:39,680

382
00:12:37,440 --> 00:12:41,279
完成工作後它必須更新此 MD 文件，同時我也想給出一些關於子代理的規則，以便它有兩個應該委派的子代理，並且當我們將任務傳遞給子代理時，確保我們在這個任務後確實被傳遞了。因此，有了

383
00:12:39,680 --> 00:12:43,040
這個設置，我們來嘗試一下。因此，我們及時

384
00:12:41,279 --> 00:12:45,360
幫助我建立了 CHBT 的副本，

385
00:12:43,040 --> 00:12:47,680
使用 chassen 作為前端，使用

386
00:12:45,360 --> 00:12:49,279
versile 作為 SDKs AI 服務。讓我們

387
00:12:47,680 --> 00:12:51,440
先建立 UI，確保我們

388
00:12:49,279 --> 00:12:53,920
諮詢子代理，首先它將

389
00:12:51,440 --> 00:12:55,839
嘗試建立此聯繫會話一個

390
00:12:53,920 --> 00:12:57,519
MD 檔案來記錄我們

391
00:12:55,839 --> 00:13:00,240
正在執行的這個專案的上下文。然後

392
00:12:57,519 --> 00:13:01,920
它觸發這個底盤代理。如果我使用

393
00:13:00,240 --> 00:13:04,000
Controlr R 打開詳細信息，您會

394
00:13:01,920 --> 00:13:06,480
看到它為這個 Chassen 專家代理提供了非常具體的任務，

395
00:13:04,000 --> 00:13:08,399
包括要

396
00:13:06,480 --> 00:13:09,920
突襲的上下文文件以及

397
00:13:08,399 --> 00:13:12,079
特定任務。然後

398
00:13:09,920 --> 00:13:14,399
這個子代理程式做的第一件事就是嘗試讀取

399
00:13:12,079 --> 00:13:17,200
這個上下文檔案。然後它開始運行

400
00:13:14,399 --> 00:13:18,959
名為 chassen components 的 MCP 工具。

401
00:13:17,200 --> 00:13:21,040
所以我們連結的是這個特殊的 MCP 工具

402
00:13:18,959 --> 00:13:22,399
。因此，如果我回到代理，

403
00:13:21,040 --> 00:13:24,480
它將不斷使用這些

404
00:13:22,399 --> 00:13:26,399
相關工具來檢索訊息，以

405
00:13:24,480 --> 00:13:28,240
幫助它使用正確的元件設計 UI。

406
00:13:26,399 --> 00:13:30,560
並且對於每個

407
00:13:28,240 --> 00:13:32,560
組件，還可以獲得一些

408
00:13:30,560 --> 00:13:35,040
如何使用它的範例程式碼。所以最後

409
00:13:32,560 --> 00:13:37,760
這個chassen代理會完成工作，

410
00:13:35,040 --> 00:13:40,800
並創建一個關於這個UI

411
00:13:37,760 --> 00:13:42,800
設計、整體佈局和要使用的計劃

412
00:13:40,800 --> 00:13:44,560
組件的doc文件，其結構非常詳細

413
00:13:42,800 --> 00:13:46,480
。在此基礎上，家長

414
00:13:44,560 --> 00:13:48,720
代理將閱讀該計劃並開始

415
00:13:46,480 --> 00:13:50,639
分解實際實施

416
00:13:48,720 --> 00:13:53,040

417
00:13:50,639 --> 00:13:55,360

418
00:13:53,040 --> 00:13:56,880

419
00:13:55,360 --> 00:13:59,199

420
00:13:56,880 --> 00:14:01,040

421
00:13:59,199 --> 00:14:03,120
。  過了一會兒，它

422
00:14:01,040 --> 00:14:04,959
一次完成了整個過程，並更新了這個上下文會話文件，以指示已經完成了哪些事情以及整體架構是什麼樣的，然後我就可以運行這個應用程式了。順便說一下，雲端程式碼只是引入了後台

423
00:14:03,120 --> 00:14:06,399
會話，它可以繼續運行並

424
00:14:04,959 --> 00:14:08,399
監控結果，這非常

425
00:14:06,399 --> 00:14:11,040
有用。如果我打開這個 UI，你可以看到

426
00:14:08,399 --> 00:14:13,120
它具有極高的保真度，

427
00:14:11,040 --> 00:14:15,040
考慮到所有細節交互，它

428
00:14:13,120 --> 00:14:17,120
看起來幾乎與 CHBT 的第一個版本相同，

429
00:14:15,040 --> 00:14:20,240

430
00:14:17,120 --> 00:14:23,040

431
00:14:20,240 --> 00:14:25,360

432
00:14:23,040 --> 00:14:27,040

433
00:14:25,360 --> 00:14:28,880

434
00:14:27,040 --> 00:14:30,720

435
00:14:28,880 --> 00:14:32,880

436
00:14:30,720 --> 00:14:35,440

437
00:14:32,880 --> 00:14:37,360
並且有一些箭頭我們可以粘貼進去開始修復這些錯誤，這就是為什麼新的子代理結構如此好，因為所有的執行都將由這個父代理完成。因此它將

438
00:14:35,440 --> 00:14:39,279
具有完整的背景。解決該問題的最佳方法是什麼？偉大的。

439
00:14:37,360 --> 00:14:42,320

440
00:14:39,279 --> 00:14:45,120

441
00:14:42,320 --> 00:14:46,800
所以現在沒有箭頭，如果我輸入一條訊息，它也會有很好的交互，動畫也得到了處理。接下來我們可以要求它連接到 versel SDK。  因此我要求它讓我們進行 vers SDK

442
00:14:45,120 --> 00:14:48,720
整合並確保諮詢

443
00:14:46,800 --> 00:14:51,199
子代理。因此這將

444
00:14:48,720 --> 00:14:53,440

445
00:14:51,199 --> 00:14:55,600
再次觸發該代理程式內的 versel AI SDK 實作規劃器，它將首先

446
00:14:53,440 --> 00:14:57,920
嘗試讀取此上下文檔案。然後它將

447
00:14:55,600 --> 00:15:00,000

448
00:14:57,920 --> 00:15:01,920

449
00:15:00,000 --> 00:15:04,160

450
00:15:01,920 --> 00:15:06,560

451
00:15:04,160 --> 00:15:09,040

452
00:15:06,560 --> 00:15:10,720

453
00:15:09,040 --> 00:15:12,959

454
00:15:10,720 --> 00:15:14,320
查看整個程式碼庫以了解實現這一點的最佳

455
00:15:12,959 --> 00:15:16,560

456
00:15:14,320 --> 00:15:18,720
方法，完成後它將創建關於 verselia SDK 實施計劃的討論，並更新此聯繫會話 MD 文件以記錄已完成的工作，然後這個父代理閱讀整個實施計劃並提出具體的實施步驟，並在完成後再次冷靜下來

457
00:15:16,560 --> 00:15:21,040

458
00:15:18,720 --> 00:15:22,959
並不斷更新此上下文

459
00:15:21,040 --> 00:15:26,000
文件。現在我們讓這個

460
00:15:22,959 --> 00:15:28,000

461
00:15:26,000 --> 00:15:29,760

462
00:15:28,000 --> 00:15:31,839

463
00:15:29,760 --> 00:15:33,839

464
00:15:31,839 --> 00:15:35,360

465
00:15:33,839 --> 00:15:37,120
應用程式運行起來

466
00:15:35,360 --> 00:15:39,120
。如果我輸入“嗨，我是 Jason”

467
00:15:37,120 --> 00:15:40,959

468
00:15:39,120 --> 00:15:42,639

469
00:15:40,959 --> 00:15:44,480
，這個代理實際上會連接到大型連結端口

470
00:15:42,639 --> 00:15:46,240

471
00:15:44,480 --> 00:15:48,560
瓶，並一次性返回結果，這是令人驚奇的部分。這是我學到的使用子代理的最佳

472
00:15:46,240 --> 00:15:50,639

473
00:15:48,560 --> 00:15:52,160
實踐的簡單範例

474
00:15:50,639 --> 00:15:53,360
。如果您

475
00:15:52,160 --> 00:15:55,199
想在比特俱樂部中了解更多信息，我會貼上

476
00:15:53,360 --> 00:15:56,800
創建我剛剛向您展示的那些子代理的所有提示過程。同時，我們

477
00:15:55,199 --> 00:15:59,040
有這個

478
00:15:56,800 --> 00:16:00,639
正在策劃的雲端程式碼模板，其中包括我們實際測試過的並且在生產環境中非常有用的鉤子、命令和代理程式清單

479
00:15:59,040 --> 00:16:03,120
。因此，如果您有興趣，可以點擊下面的連結加入 AI 建構者俱樂部。我們也每週舉行一次會議，討論每週學到的最佳實踐。希望您喜歡這個視頻。謝謝，

480
00:16:00,639 --> 00:16:03,120
下次見

